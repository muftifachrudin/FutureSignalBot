name: Build and Deploy to Azure Container Apps

on:
  push:
    branches: ["main"]
  workflow_dispatch:

concurrency:
  group: deploy-aca
  cancel-in-progress: true

permissions:
  contents: read
  id-token: write

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      RG: ${{ vars.AZURE_RESOURCE_GROUP }}
      LOCATION: ${{ vars.AZURE_LOCATION }}
      ACR_NAME: ${{ vars.ACR_NAME }}
      ENV_NAME: ${{ vars.ACA_ENV_NAME }}
      APP_NAME: ${{ vars.ACA_APP_NAME }}
      IMAGE_NAME: futuresignalbot
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Install containerapp extension
        uses: azure/cli@v2
        with:
          inlineScript: az extension add -n containerapp --upgrade

      - name: Prepare ACR
        id: acr
        uses: azure/cli@v2
        with:
          inlineScript: |
            set -e
            [ -z "$RG" ] && echo "Missing RG" && exit 1
            [ -z "$LOCATION" ] && echo "Missing LOCATION" && exit 1
            [ -z "$ACR_NAME" ] && echo "Missing ACR_NAME" && exit 1
            az group create -n "$RG" -l "$LOCATION" 1> /dev/null
            if ! az acr show -n "$ACR_NAME" -g "$RG" 1> /dev/null 2>&1; then
              az acr create -n "$ACR_NAME" -g "$RG" -l "$LOCATION" --sku Basic --admin-enabled true 1> /dev/null
            fi
            ACR_LOGIN_SERVER=$(az acr show -n "$ACR_NAME" -g "$RG" --query loginServer -o tsv)
            ACR_USERNAME=$(az acr credential show -n "$ACR_NAME" -g "$RG" --query username -o tsv)
            ACR_PASSWORD=$(az acr credential show -n "$ACR_NAME" -g "$RG" --query passwords[0].value -o tsv)
            echo "::add-mask::$ACR_PASSWORD"
            echo "acr_login_server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT
            echo "acr_username=$ACR_USERNAME" >> $GITHUB_OUTPUT
            echo "acr_password=$ACR_PASSWORD" >> $GITHUB_OUTPUT

      - name: Docker login
        uses: docker/login-action@v3
        with:
          registry: ${{ steps.acr.outputs.acr_login_server }}
          username: ${{ steps.acr.outputs.acr_username }}
          password: ${{ steps.acr.outputs.acr_password }}

      - name: Build & push image
        run: |
          set -e
          REG=${{ steps.acr.outputs.acr_login_server }}
          IMAGE_SHA=$REG/${{ env.IMAGE_NAME }}:${GITHUB_SHA}
          IMAGE_LATEST=$REG/${{ env.IMAGE_NAME }}:latest
          docker build -t "$IMAGE_SHA" -t "$IMAGE_LATEST" .
          docker push "$IMAGE_SHA"
          docker push "$IMAGE_LATEST"
          echo "IMAGE_TAG=$IMAGE_LATEST" >> $GITHUB_ENV

      - name: Provision Container Apps Environment
        uses: azure/cli@v2
        with:
          inlineScript: |
            set -e
            [ -z "$ENV_NAME" ] && echo "Missing ENV_NAME" && exit 1
            LAW_NAME="${ENV_NAME}-law"
            if ! az monitor log-analytics workspace show -g "$RG" -n "$LAW_NAME" 1> /dev/null 2>&1; then
              az monitor log-analytics workspace create -g "$RG" -n "$LAW_NAME" -l "$LOCATION" 1> /dev/null
            fi
            LAW_ID=$(az monitor log-analytics workspace show -g "$RG" -n "$LAW_NAME" --query customerId -o tsv)
            LAW_KEY=$(az monitor log-analytics workspace get-shared-keys -g "$RG" -n "$LAW_NAME" --query primarySharedKey -o tsv)
            if ! az containerapp env show -g "$RG" -n "$ENV_NAME" 1> /dev/null 2>&1; then
              az containerapp env create -g "$RG" -n "$ENV_NAME" -l "$LOCATION" --logs-workspace-id "$LAW_ID" --logs-workspace-key "$LAW_KEY" 1> /dev/null
            fi

      - name: Deploy / Update Container App
        uses: azure/cli@v2
        env:
          telegram-bot-token: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          coinglass-api-key: ${{ secrets.COINGLASS_API_KEY }}
          mexc-api-key: ${{ secrets.MEXC_API_KEY }}
          mexc-secret-key: ${{ secrets.MEXC_SECRET_KEY }}
          gemini-api-key: ${{ secrets.GEMINI_API_KEY }}
        with:
          inlineScript: |
            set -e
            IMAGE="$IMAGE_TAG"
            REG=${{ steps.acr.outputs.acr_login_server }}
            USER=${{ steps.acr.outputs.acr_username }}
            PASS=${{ steps.acr.outputs.acr_password }}
            # Validate required secret
            [ -z "$TELEGRAM_BOT_TOKEN" ] && echo "Missing TELEGRAM_BOT_TOKEN secret" && exit 1
            # Build secrets args dynamically (lowercase names) only for non-empty values
            secret_args=(telegram-bot-token="$TELEGRAM_BOT_TOKEN")
            [ -n "$COINGLASS_API_KEY" ] && secret_args+=(coinglass-api-key="$COINGLASS_API_KEY")
            [ -n "$MEXC_API_KEY" ] && secret_args+=(mexc-api-key="$MEXC_API_KEY")
            [ -n "$MEXC_SECRET_KEY" ] && secret_args+=(mexc-secret-key="$MEXC_SECRET_KEY")
            [ -n "$GEMINI_API_KEY" ] && secret_args+=(gemini-api-key="$GEMINI_API_KEY")
            # Apply secrets (ignore failure if app not yet exists - handled in create path)
            az containerapp secret set -g "$RG" -n "$APP_NAME" --secrets "${secret_args[@]}" 2>/dev/null || true
            # Map to env vars expected by the app
            ENV_VARS="TELEGRAM_BOT_TOKEN=secretref:telegram-bot-token"
            [ -n "$COINGLASS_API_KEY" ] && ENV_VARS+=" COINGLASS_API_KEY=secretref:coinglass-api-key"
            [ -n "$MEXC_API_KEY" ] && ENV_VARS+=" MEXC_API_KEY=secretref:mexc-api-key"
            [ -n "$MEXC_SECRET_KEY" ] && ENV_VARS+=" MEXC_SECRET_KEY=secretref:mexc-secret-key"
            [ -n "$GEMINI_API_KEY" ] && ENV_VARS+=" GEMINI_API_KEY=secretref:gemini-api-key"
            if az containerapp show -g "$RG" -n "$APP_NAME" 1> /dev/null 2>&1; then
              az containerapp update -g "$RG" -n "$APP_NAME" --image "$IMAGE" \
                --registry-server "$REG" --registry-username "$USER" --registry-password "$PASS" \
                --set-env-vars $ENV_VARS --min-replicas 1 --max-replicas 1 --cpu 0.25 --memory 0.5Gi 1> /dev/null
            else
              az containerapp create -g "$RG" -n "$APP_NAME" --environment "$ENV_NAME" --image "$IMAGE" \
                --registry-server "$REG" --registry-username "$USER" --registry-password "$PASS" \
                --secrets "${secret_args[@]}" \
                --env-vars $ENV_VARS --min-replicas 1 --max-replicas 1 --cpu 0.25 --memory 0.5Gi 1> /dev/null
            fi

      - name: Show Revisions
        uses: azure/cli@v2
        with:
          inlineScript: az containerapp revision list -g "$RG" -n "$APP_NAME" -o table || true
