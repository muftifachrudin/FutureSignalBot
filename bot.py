"""
Telegram bot implementation for trading signals
"""
import asyncio
import logging
from typing import Dict, List, Optional
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, MessageHandler, filters, ContextTypes
from signal_generator import SignalGenerator
from config import Config
from utils import (
    format_signal_message, format_market_analysis, format_pairs_list,
    validate_symbol, format_error_message, get_timeframe_display, truncate_text
)
from config import Config

logger = logging.getLogger(__name__)

class TradingSignalBot:
    """Main Telegram bot class"""
    
    def __init__(self):
        self.token = Config.TELEGRAM_BOT_TOKEN
        self.signal_generator = None
        self.application = None
        self.user_sessions = {}  # Track user sessions
    
    async def start(self):
        """Start the bot"""
        try:
            # Initialize signal generator
            self.signal_generator = SignalGenerator()
            await self.signal_generator.__aenter__()
            
            # Create application
            self.application = Application.builder().token(self.token).build()
            
            # Add handlers
            self._add_handlers()
            
            # Start the bot
            logger.info("Starting Telegram bot...")
            await self.application.initialize()
            await self.application.start()
            await self.application.updater.start_polling()
            
            # Keep running
            logger.info("Bot started successfully!")
            
            # Keep the bot running
            import asyncio
            await asyncio.Future()  # Run forever
            
        except Exception as e:
            logger.error(f"Error starting bot: {e}")
            raise
        finally:
            # Cleanup
            if self.signal_generator:
                await self.signal_generator.__aexit__(None, None, None)
    
    def _add_handlers(self):
        """Add command and callback handlers"""
        # Command handlers
        self.application.add_handler(CommandHandler("start", self.start_command))
        self.application.add_handler(CommandHandler("help", self.help_command))
        self.application.add_handler(CommandHandler("signal", self.signal_command))
        self.application.add_handler(CommandHandler("analyze", self.analyze_command))
        self.application.add_handler(CommandHandler("pairs", self.pairs_command))
        self.application.add_handler(CommandHandler("timeframes", self.timeframes_command))
        self.application.add_handler(CommandHandler("about", self.about_command))
        
        # Callback query handler for inline keyboards
        self.application.add_handler(CallbackQueryHandler(self.button_callback))
        
        # Message handler for direct symbol input
        self.application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, self.handle_symbol_message))
    
    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /start command"""
        welcome_message = """
ü§ñ **Welcome to MEXC Futures Trading Signals Bot!**

This bot provides AI-powered trading signals for MEXC futures using:
‚Ä¢ üìä Multi-timeframe analysis (5m, 15m, 30m, 1h, 4h)  
‚Ä¢ üìà Coinglass market data
‚Ä¢ ü§ñ Gemini AI analysis
‚Ä¢ üíπ MEXC exchange data

**Available Commands:**
‚Ä¢ `/signal <SYMBOL>` - Get trading signal
‚Ä¢ `/analyze <SYMBOL>` - Get market analysis  
‚Ä¢ `/pairs` - View supported pairs
‚Ä¢ `/timeframes` - View analyzed timeframes
‚Ä¢ `/help` - Show detailed help
‚Ä¢ `/about` - About this bot

**Example Usage:**
‚Ä¢ `/signal BTCUSDT` - Get BTC signal
‚Ä¢ `/analyze ETHUSDT` - Analyze ETH market

‚ö†Ô∏è **Disclaimer:** This bot provides educational signals only. Always do your own research and manage risk appropriately.
"""
        
        keyboard = [
            [InlineKeyboardButton("üìä Popular Pairs", callback_data="popular_pairs")],
            [InlineKeyboardButton("üìà Get Signal", callback_data="get_signal"), 
             InlineKeyboardButton("üîç Market Analysis", callback_data="market_analysis")],
            [InlineKeyboardButton("‚ÑπÔ∏è Help", callback_data="help")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await update.message.reply_text(welcome_message, reply_markup=reply_markup, parse_mode='Markdown')
    
    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /help command"""
        help_message = """
üìö **Detailed Help Guide**

**üéØ Signal Commands:**
‚Ä¢ `/signal BTCUSDT` - Get trading signal for Bitcoin
‚Ä¢ `/signal ETH` - Get signal (USDT automatically added)

**üìä Analysis Commands:**  
‚Ä¢ `/analyze BTCUSDT` - Get detailed market analysis
‚Ä¢ `/pairs` - List all supported trading pairs
‚Ä¢ `/timeframes` - Show analyzed timeframes

**ü§ñ Signal Types:**
‚Ä¢ üü¢ **LONG** - Buy signal with bullish conditions
‚Ä¢ üî¥ **SHORT** - Sell signal with bearish conditions  
‚Ä¢ üü° **WAIT** - Hold/wait signal for unclear conditions

**üìà Analysis Factors:**
‚Ä¢ Price trends across 5 timeframes
‚Ä¢ Open interest changes
‚Ä¢ Funding rates
‚Ä¢ Long/short position ratios
‚Ä¢ Volume confirmation
‚Ä¢ Support/resistance levels

**‚ö†Ô∏è Risk Management:**
‚Ä¢ Always use stop losses
‚Ä¢ Position size appropriately
‚Ä¢ Don't risk more than you can afford
‚Ä¢ Signals are educational only

**üîÑ Rate Limits:**
‚Ä¢ 5-minute cooldown between signals for same pair
‚Ä¢ This prevents spam and ensures quality analysis

**üí° Tips:**
‚Ä¢ Use signals as part of broader analysis
‚Ä¢ Combine with your own research
‚Ä¢ Monitor multiple timeframes
‚Ä¢ Follow risk management rules
"""
        
        await update.message.reply_text(help_message, parse_mode='Markdown')
    
    async def signal_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /signal command"""
        try:
            # Get symbol from command arguments
            if not context.args:
                await update.message.reply_text(
                    "‚ùå Please provide a trading symbol.\n\n**Usage:** `/signal BTCUSDT`",
                    parse_mode='Markdown'
                )
                return
            
            symbol = validate_symbol(context.args[0])
            
            # Show processing message
            processing_msg = await update.message.reply_text(
                f"üîÑ **Analyzing {symbol}...**\n\nGathering data from multiple sources...",
                parse_mode='Markdown'
            )
            
            # Generate signal
            signal = await self.signal_generator.generate_signal(symbol)
            
            if signal:
                # Format and send signal
                message = format_signal_message(symbol, signal.dict())
                message += f"\n\n{get_timeframe_display()}"
                
                # Add action buttons
                keyboard = [
                    [InlineKeyboardButton("üîÑ Refresh Signal", callback_data=f"refresh_signal_{symbol}")],
                    [InlineKeyboardButton("üìä Market Analysis", callback_data=f"analyze_{symbol}")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                await processing_msg.edit_text(truncate_text(message), reply_markup=reply_markup, parse_mode='Markdown')
            else:
                error_msg = format_error_message("Failed to generate signal. Please try again later.", symbol)
                await processing_msg.edit_text(error_msg, parse_mode='Markdown')
                
        except ValueError as e:
            await update.message.reply_text(format_error_message(str(e)), parse_mode='Markdown')
        except Exception as e:
            logger.error(f"Error in signal command: {e}")
            await update.message.reply_text(
                format_error_message("An unexpected error occurred.", context.args[0] if context.args else None),
                parse_mode='Markdown'
            )
    
    async def analyze_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /analyze command"""
        try:
            if not context.args:
                await update.message.reply_text(
                    "‚ùå Please provide a trading symbol.\n\n**Usage:** `/analyze BTCUSDT`",
                    parse_mode='Markdown'
                )
                return
            
            symbol = validate_symbol(context.args[0])
            
            # Show processing message
            processing_msg = await update.message.reply_text(
                f"üîç **Analyzing market conditions for {symbol}...**",
                parse_mode='Markdown'
            )
            
            # Get market explanation
            analysis = await self.signal_generator.get_market_explanation(symbol)
            
            if analysis:
                message = format_market_analysis(symbol, analysis)
                
                # Add action buttons
                keyboard = [
                    [InlineKeyboardButton("üéØ Get Signal", callback_data=f"signal_{symbol}")],
                    [InlineKeyboardButton("üîÑ Refresh Analysis", callback_data=f"analyze_{symbol}")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                await processing_msg.edit_text(truncate_text(message), reply_markup=reply_markup, parse_mode='Markdown')
            else:
                error_msg = format_error_message("Failed to analyze market conditions.", symbol)
                await processing_msg.edit_text(error_msg, parse_mode='Markdown')
                
        except ValueError as e:
            await update.message.reply_text(format_error_message(str(e)), parse_mode='Markdown')
        except Exception as e:
            logger.error(f"Error in analyze command: {e}")
            await update.message.reply_text(
                format_error_message("An unexpected error occurred.", context.args[0] if context.args else None),
                parse_mode='Markdown'
            )
    
    async def pairs_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /pairs command"""
        try:
            processing_msg = await update.message.reply_text("üîÑ **Loading supported pairs...**", parse_mode='Markdown')
            
            pairs = await self.signal_generator.get_supported_pairs()
            
            if pairs:
                message = format_pairs_list(pairs)
                
                # Add navigation buttons for pagination if needed
                keyboard = [
                    [InlineKeyboardButton("üéØ Get Signal", callback_data="get_signal_input")],
                    [InlineKeyboardButton("üîÑ Refresh List", callback_data="refresh_pairs")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                await processing_msg.edit_text(message, reply_markup=reply_markup, parse_mode='Markdown')
            else:
                error_msg = format_error_message("Failed to load supported pairs.")
                await processing_msg.edit_text(error_msg, parse_mode='Markdown')
                
        except Exception as e:
            logger.error(f"Error in pairs command: {e}")
            await update.message.reply_text(
                format_error_message("An unexpected error occurred while loading pairs."),
                parse_mode='Markdown'
            )
    
    async def timeframes_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /timeframes command"""
        message = f"""
‚è∞ **Analyzed Timeframes**

This bot analyzes the following timeframes for comprehensive market analysis:

‚Ä¢ **5 minutes** - Short-term scalping signals
‚Ä¢ **15 minutes** - Quick swing opportunities  
‚Ä¢ **30 minutes** - Medium-term trends
‚Ä¢ **1 hour** - Hourly trend confirmation
‚Ä¢ **4 hours** - Major trend direction

**How it works:**
üîç Each timeframe is analyzed for trend direction
üìä Signals are generated when multiple timeframes align
‚öñÔ∏è Higher timeframe trends have more weight
üéØ Best signals occur when all timeframes agree

{get_timeframe_display()}

**Signal Quality:**
‚Ä¢ üü¢ **High**: 4-5 timeframes aligned
‚Ä¢ üü° **Medium**: 3 timeframes aligned  
‚Ä¢ üî¥ **Low**: 2 or fewer aligned
"""
        
        keyboard = [
            [InlineKeyboardButton("üéØ Get Signal", callback_data="get_signal_input")],
            [InlineKeyboardButton("üìä Popular Pairs", callback_data="popular_pairs")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await update.message.reply_text(message, reply_markup=reply_markup, parse_mode='Markdown')
    
    async def about_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /about command"""
        about_message = """
ü§ñ **MEXC Futures Trading Signals Bot**

**üîß Technology Stack:**
‚Ä¢ ü§ñ Gemini AI for intelligent analysis
‚Ä¢ üìä Coinglass API for market sentiment
‚Ä¢ üíπ MEXC API for trading data
‚Ä¢ ‚ö° Real-time multi-timeframe analysis

**üìà Data Sources:**
‚Ä¢ Price action across 5 timeframes
‚Ä¢ Open interest changes
‚Ä¢ Funding rates
‚Ä¢ Long/short position ratios
‚Ä¢ Volume and volatility metrics
‚Ä¢ Support/resistance levels

**üéØ Signal Logic:**
‚Ä¢ **LONG**: Bullish alignment + positive funding + high short ratio + rising OI
‚Ä¢ **SHORT**: Bearish alignment + negative funding + high long ratio + declining OI  
‚Ä¢ **WAIT**: Mixed signals or unclear market conditions

**‚ö†Ô∏è Important Disclaimers:**
‚Ä¢ Signals are for educational purposes only
‚Ä¢ Past performance doesn't guarantee future results
‚Ä¢ Always use proper risk management
‚Ä¢ Never invest more than you can afford to lose
‚Ä¢ This is not financial advice

**üîí Security:**
‚Ä¢ No trading permissions required
‚Ä¢ Read-only market data access
‚Ä¢ Secure API key management
‚Ä¢ No personal data stored

**üìß Support:**
For technical issues or questions, please contact support.

**Version:** 1.0.0
**Last Updated:** 2025
"""
        
        await update.message.reply_text(about_message, parse_mode='Markdown')
    
    async def button_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle inline keyboard button callbacks"""
        query = update.callback_query
        await query.answer()
        
        data = query.data
        
        try:
            if data == "popular_pairs":
                await self._handle_popular_pairs(query)
            elif data == "get_signal":
                await self._handle_get_signal_prompt(query)
            elif data == "market_analysis":
                await self._handle_market_analysis_prompt(query)
            elif data == "help":
                await self._handle_help_callback(query)
            elif data.startswith("signal_"):
                symbol = data.split("_", 1)[1]
                await self._handle_signal_callback(query, symbol)
            elif data.startswith("analyze_"):
                symbol = data.split("_", 1)[1]
                await self._handle_analyze_callback(query, symbol)
            elif data.startswith("refresh_signal_"):
                symbol = data.split("_", 2)[2]
                await self._handle_refresh_signal(query, symbol)
            elif data == "refresh_pairs":
                await self._handle_refresh_pairs(query)
            else:
                await query.edit_message_text("‚ùå Unknown action.")
                
        except Exception as e:
            logger.error(f"Error handling callback {data}: {e}")
            await query.edit_message_text("‚ùå An error occurred. Please try again.")
    
    async def handle_symbol_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle direct symbol messages"""
        try:
            symbol = validate_symbol(update.message.text)
            
            # Create quick action buttons
            keyboard = [
                [InlineKeyboardButton("üéØ Get Signal", callback_data=f"signal_{symbol}")],
                [InlineKeyboardButton("üìä Market Analysis", callback_data=f"analyze_{symbol}")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await update.message.reply_text(
                f"üìà **{symbol}** - What would you like to do?",
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )
            
        except ValueError:
            await update.message.reply_text(
                "‚ùå Invalid symbol format. Please use format like `BTCUSDT` or `/help` for assistance.",
                parse_mode='Markdown'
            )
    
    async def _handle_popular_pairs(self, query):
        """Handle popular pairs button"""
        popular_pairs = ["BTCUSDT", "ETHUSDT", "BNBUSDT", "ADAUSDT", "SOLUSDT", "DOGEUSDT", "XRPUSDT", "DOTUSDT"]
        
        message = "üî• **Popular Trading Pairs**\n\nSelect a pair to get signals:\n\n"
        
        keyboard = []
        for i in range(0, len(popular_pairs), 2):
            row = []
            for j in range(2):
                if i + j < len(popular_pairs):
                    pair = popular_pairs[i + j]
                    row.append(InlineKeyboardButton(pair, callback_data=f"signal_{pair}"))
            keyboard.append(row)
        
        keyboard.append([InlineKeyboardButton("üìã All Pairs", callback_data="refresh_pairs")])
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(message, reply_markup=reply_markup, parse_mode='Markdown')
    
    async def _handle_get_signal_prompt(self, query):
        """Handle get signal prompt"""
        message = """
üéØ **Get Trading Signal**

Send me a trading symbol to get AI-powered analysis:

**Examples:**
‚Ä¢ `BTCUSDT` or just `BTC`
‚Ä¢ `ETHUSDT` or just `ETH`  
‚Ä¢ `ADAUSDT` or just `ADA`

Or use: `/signal SYMBOL`
"""
        
        keyboard = [[InlineKeyboardButton("üî• Popular Pairs", callback_data="popular_pairs")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(message, reply_markup=reply_markup, parse_mode='Markdown')
    
    async def _handle_market_analysis_prompt(self, query):
        """Handle market analysis prompt"""
        message = """
üìä **Market Analysis**

Send me a trading symbol for detailed market analysis:

**Examples:**
‚Ä¢ `BTCUSDT` - Bitcoin analysis
‚Ä¢ `ETHUSDT` - Ethereum analysis
‚Ä¢ `BNBUSDT` - Binance Coin analysis

Or use: `/analyze SYMBOL`
"""
        
        keyboard = [[InlineKeyboardButton("üî• Popular Pairs", callback_data="popular_pairs")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(message, reply_markup=reply_markup, parse_mode='Markdown')
    
    async def _handle_help_callback(self, query):
        """Handle help button callback"""
        help_message = """
üìö **Quick Help**

**Commands:**
‚Ä¢ `/signal BTCUSDT` - Get trading signal
‚Ä¢ `/analyze ETHUSDT` - Market analysis
‚Ä¢ `/pairs` - Supported pairs
‚Ä¢ `/help` - Detailed help

**Signal Types:**
‚Ä¢ üü¢ LONG - Buy signal
‚Ä¢ üî¥ SHORT - Sell signal  
‚Ä¢ üü° WAIT - Hold position

**Usage Tips:**
‚Ä¢ Signals update every 5 minutes
‚Ä¢ Use with proper risk management
‚Ä¢ Educational purposes only

**More help:** `/help`
"""
        
        keyboard = [
            [InlineKeyboardButton("üéØ Get Signal", callback_data="get_signal")],
            [InlineKeyboardButton("üìä Analysis", callback_data="market_analysis")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(help_message, reply_markup=reply_markup, parse_mode='Markdown')
    
    async def _handle_signal_callback(self, query, symbol: str):
        """Handle signal callback for specific symbol"""
        await query.edit_message_text(
            f"üîÑ **Generating signal for {symbol}...**\n\nAnalyzing market data...",
            parse_mode='Markdown'
        )
        
        signal = await self.signal_generator.generate_signal(symbol)
        
        if signal:
            message = format_signal_message(symbol, signal.dict())
            message += f"\n\n{get_timeframe_display()}"
            
            keyboard = [
                [InlineKeyboardButton("üîÑ Refresh", callback_data=f"refresh_signal_{symbol}")],
                [InlineKeyboardButton("üìä Analysis", callback_data=f"analyze_{symbol}")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await query.edit_message_text(truncate_text(message), reply_markup=reply_markup, parse_mode='Markdown')
        else:
            error_msg = format_error_message("Failed to generate signal.", symbol)
            await query.edit_message_text(error_msg, parse_mode='Markdown')
    
    async def _handle_analyze_callback(self, query, symbol: str):
        """Handle analyze callback for specific symbol"""
        await query.edit_message_text(
            f"üîç **Analyzing {symbol}...**\n\nGathering market data...",
            parse_mode='Markdown'
        )
        
        analysis = await self.signal_generator.get_market_explanation(symbol)
        
        if analysis:
            message = format_market_analysis(symbol, analysis)
            
            keyboard = [
                [InlineKeyboardButton("üéØ Get Signal", callback_data=f"signal_{symbol}")],
                [InlineKeyboardButton("üîÑ Refresh", callback_data=f"analyze_{symbol}")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await query.edit_message_text(truncate_text(message), reply_markup=reply_markup, parse_mode='Markdown')
        else:
            error_msg = format_error_message("Failed to analyze market.", symbol)
            await query.edit_message_text(error_msg, parse_mode='Markdown')
    
    async def _handle_refresh_signal(self, query, symbol: str):
        """Handle refresh signal callback"""
        await query.edit_message_text(
            f"üîÑ **Refreshing signal for {symbol}...**",
            parse_mode='Markdown'
        )
        
        signal = await self.signal_generator.generate_signal(symbol, force=True)
        
        if signal:
            message = format_signal_message(symbol, signal.dict())
            message += f"\n\n{get_timeframe_display()}"
            
            keyboard = [
                [InlineKeyboardButton("üîÑ Refresh", callback_data=f"refresh_signal_{symbol}")],
                [InlineKeyboardButton("üìä Analysis", callback_data=f"analyze_{symbol}")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await query.edit_message_text(truncate_text(message), reply_markup=reply_markup, parse_mode='Markdown')
        else:
            error_msg = format_error_message("Failed to refresh signal.", symbol)
            await query.edit_message_text(error_msg, parse_mode='Markdown')
    
    async def _handle_refresh_pairs(self, query):
        """Handle refresh pairs callback"""
        await query.edit_message_text("üîÑ **Loading supported pairs...**", parse_mode='Markdown')
        
        pairs = await self.signal_generator.get_supported_pairs()
        
        if pairs:
            message = format_pairs_list(pairs)
            
            keyboard = [
                [InlineKeyboardButton("üéØ Get Signal", callback_data="get_signal")],
                [InlineKeyboardButton("üîÑ Refresh", callback_data="refresh_pairs")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await query.edit_message_text(message, reply_markup=reply_markup, parse_mode='Markdown')
        else:
            error_msg = format_error_message("Failed to load pairs.")
            await query.edit_message_text(error_msg, parse_mode='Markdown')
